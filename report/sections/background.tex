This section describes in further detail some key concepts that are relevant to the research, and provides a more detailed problem statement and requirements for the project.

\subsubsection*{The platform}\label{sec:platform}
The platform used for the experiments in this project is the Texas Instruments MSP430FR5994 16MHz microcontroller. The MSP430FR5994 features a 16-bit RISC architecture and is equipped with 256KB of FRAM (Ferroelectric Random Access Memory), 8KB of SRAM, and 2KB of flash memory. The relatively large FRAM is particularly useful for this project since it is a non-volatile memory which at the same time provides high speed writes and low power consumption. This comes as a result of FRAM being addressable in a bit-wise manner, although on the byte level in the code, as opposed to Flash memory or EEPROM which requires entire pages to be erased before new data can be written, slowing down the operations \cite{framReport}. A side-effect of FRAM being non-volatile is that the binary image of the program is stored in the same place that it is executed from, and can thus be updated in-place with little overhead.

FRAM is also a low power memory technology since it doesn't require a charge pump to write data, as opposed to Flash memory or EEPROM. This is particularly useful in battery-powered devices, where power consumption is a critical factor. In addition to the speed, power efficiency and non-volatility, FRAM also has a much higher endurance than Flash memory, with a specified $10^{15}$ write cycles \cite{framReport}. This makes it a suitable candidate for devices that are expected to run continuously for long periods of time, devices which would benefit greatly from the ability to update the software in the field.

One drawback of FRAM is that accesses to it are limited to 8MHz. Thus, if the microcontroller is running at 16MHz, the CPU will be stalled for every access to FRAM \cite{framReport}. This is a limitation that must be considered when measuring the performance of the update process. The wait states require no user interaction apart from the initial setup of the microcontroller, and are handled automatically by the CPU.

\textbf{\textit{Memory layout}}. The MSP430FR5994 uses a unified memory model where FRAM, SRAM and registers can be accessed in the same memory space. The memory layout of the MSP430FR5994 can be seen in table \ref{tab:memory_layout}.
\begin{table}
\centering
\begin{tabular}{|p{0.55\linewidth}|c|c|}
    \hline
    \textbf{Memory} & \textbf{Address range} & \textbf{Size} \\
    \hline
    Reserved, Tiny RAM, Peripherals & 0x0000-0x0FFF & 4KB \\
    \hline
    Bootloader memory (ROM) & 0x1000-0x17FF & 2KB \\
    \hline
    Information memory, Device Descriptor (FRAM) & 0x1800-0x1AFF & 768B \\
    \hline
    VACANT & 0x1B00-0x1BFF & 256B \\
    \hline
    \textbf{RAM} & \textbf{0x1C00-0x3BFF} & \textbf{8KB} \\
    \hline
    \textbf{Code and Data memory, Interrupt vectors (FRAM)} & \textbf{0x4000-0x43FFF} & \textbf{256KB} \\
    \hline
\end{tabular}
\caption{Memory layout of the MSP430FR5994 microcontroller \cite{fr5994DataSheet}.}
\label{tab:memory_layout}
\end{table}

The table has been simplified to highlight the important parts of discussion for this research. Essentially, the final section of the memory space is the main memory used in any application running on the device. This is where the binary image of the program is stored, and where the update process will take place. The memory space is automatically divided into two sections by the compiler and linker, FRAM (0x4000-0xFFFF) and HIFRAM (0x10000 - 0x43FFF). This is due to the fact that the 16-bit architecture of the microprocessor doesn't allow addressing beyond 16-bit memory addresses. Accessing the HIFRAM section is only possible with an extension of the instruction set, using less efficient, emulated instructions. How these sections are used is up to the developer and can be configured in the linker script. 

To facilitate an efficient update process, the program should be structured in such a way that the added or removed code affects the rest of the program as little as possible. For example, moving a function in memory requires that all calls to said function are updated, which can be a time-consuming process. Thus, in this research, the memory layout opted for is to have the DSU functionality in the FRAM section, with all other application code in the HIFRAM section. This way, the DSU code is never affected by the update process, which would be the case if it was stored in the same section as the application code. 

The drawback of this approach is that the program code is not as fast to access as it would be if it was stored in the FRAM section. This is a trade-off that was deemed necessary due to the decrease in complexity of any update performed.  

\subsubsection*{Problem statement}
As described in previous sections, DSU in embedded and real-time systems is not a new concept, but there are some key aspects that are yet to be considered in the field. 

Firstly; the currently existing work in the field of DSU have been focused on systems with more relaxed real-time requirements, where the overhead of the update process is not as critical. This project aims to investigate the use of DSU in systems with tighter real-time deadlines, where the overhead of the update process must be kept to a minimum.

Secondly; to meet these deadlines, the utilisation of FRAM is proposed as a potential solution, and this research aims to investigate the performance impact that the technology has on the update process.  

\subsubsection*{Requirements}
As a way of containing the scope of the project, and to provide a clear goal for the research, the requirements of the work need to be clearly defined. There are a multitude of requirements to consider in the context of DSU, both functional and non-functional. MlinariÄ‡ describes in \cite{dsuChallenges} five key requirements for any DSU implementation, namely: \textit{Availability}, \textit{Correctness}, \textit{Flexibility}, \textit{Performance}, and \textit{Simplicity}. In addition to these general requirements for DSU, there are also requirements that are specific to the context of embedded systems, which may be considered subcategories of the above; \textit{Energy efficiency}, \textit{Memory usage}, and \textit{Security}.
\todo{Maybe expand on these}

The main focus of this research is the performance of the update process, however other aspects such as security and correctness are considered when evaluating the results, as they are factors which may impact the performance, and thus, the feasibility of the solution.