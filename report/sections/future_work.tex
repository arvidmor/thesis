This section will present some ideas for future work, based on the known drawbacks and limitations of the DSU implementation. The main focus of the future work is to improve the performance of the DSU process, and to improve on the other aspects of a feasible DSU solution.
\subsection*{Memory usage}
The implementation in its current state may be considered quite memory inefficient. This mainly comes as a consequence of the two stages of the update process, where intermediate data has to be stored. The implementation uses three statically allocated arrays, one for the \textit{diff} file, one for storing the various \textit{operations} of the patch, and one for the data used by these operations. The size of these arrays could be reduced in a future implementation, but it would risk limiting the size of possible updates. Another solution could be to use dynamically allocated memory, but this was avoided for this research since it is generally not recommended in real-time systems. A possible solution could be to verify the patch file with a checksum, and then apply the patch file directly to the binary image, without storing intermediate data. This would require a more complex implementation, but could potentially save a lot of memory.

\subsection*{Decode performance}
The decode phase of the DSU process is the most time consuming, and thus the most critical to optimise. The current implementation is naive in that every word of data has to be stated explicitly in the patch file. This is quite an inefficient way to describe changes where a single word should be written in multiple places. An example of such a scenario is function relocation; If a function is moved to another address, every call to this function needs to be updated. This could be described with a new operation type, which would allow for a single word to be written to multiple addresses. This would require a slightly more complex implementation, but could potentially save a lot of time in the decode phase. 

\subsection*{Atomicity}
As previously stated, the current implementation has no way of guaranteeing atomicity of the update process. This could be a critical issue in a real-time system, where the system must be able to recover from a failed update. A possible solution could be to implement a rollback mechanism, where the old state is saved, and then the patch file is applied in reverse. This would require a more complex implementation, but could potentially save the system from a failed update.
