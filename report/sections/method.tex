\todo{Section introduction}

\subsection{Patch file}\label{sec:patchfile}
To meet the requirements of timeliness and memory usage, an efficient way of describing the update is essential. The method chosen for this project is to use a patch file that describes the changes to be made to the binary image.
The patch file must be minimal in size to keep the transfer- and decode times within the expected idle time. This naturally excludes simply transferring the entire binary image as an option. Instead, a \textit{lambda}-file is generated by a server system by comparing the current binary to the patched one. For sufficiently small updates, the lambda file could be as simple as stating addresses to changed instructions and/or data, and the new values for said addresses. This is however not ideal in the case of bigger updates since changes could cause portions of the binary to be shifted, which can be expressed with a \textbf{Shift} operation instead of individual byte- or word-level changes. Thus, a better approach is to use a binary diffing tool such as \textit{BinDiff} to generate a patch file. The scope of this project however, does not include implementing a way to generate these lambda files. The solution employed was instead to keep manually created lambda files for updates of various complexities, to allow for testing of the update procedure itself. 

\subsubsection*{Lambda file format}
\todo{Diagram}
The lambda file is a text file that describes the changes to be made to the binary image. In this research, two main types of operations are considered: \textbf{Write} and \textbf{Shift}. The \textbf{Write} operation describes a change to a specific address, or range of addresses in the binary image, while the \textbf{Shift} operation describes a change that causes a portion of the binary image to be shifted. The format of the lambda file is as follows:

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Operation} & \textbf{Address} & \textbf{No. words}  & \textbf{Data} \\
\hline
\end{tabular}
\end{center}
As the operations work fundamentally differently, the semantics of the fields of the lambda file depend on the operation. As an example, for a \textbf{Write} operation, the \textbf{No. words} describes the length of the data field, while for a \textbf{Shift} operation, it describes the offset to shift by.
\subsection{The update procedure}\label{sec:updateprocedure}
With the main requirements of the implementation defined, the next step is to design an update procedure that meets the these requirements. The update procedure is the part of the process that is responsible for applying the patch file to the application. This is where the majority of the research conducted was focused. Firstly, for robustness and to simplify the implementation and testing, the update procedure was split into two phases: \textbf{Decode}, and \textbf{Apply}. This separation allows for the lambda file to be decoded and verified before the actual update is applied, an important property since the update procedure must be able to handle errors in the patch file, such as corruption or tampering. It also benefits debugging and profiling of the procedure, as the two phases can be tested separately. The following sections will describe these phases in further detail. 

\subsubsection*{Decode}
The Decode phase is responsible for reading the patch file and translating it into a format that can be used to apply the update. The patch file is read from the FRAM and decoded into a data structure that represents the changes to be made, which can be seen in listing \ref{lst:diff_struct}. 
\begin{lstlisting}[
    caption={The data structure used to represent the changes in the patch file.},
    label={lst:diff_struct}
]
typedef struct {
  unsigned char operation; // Operation to perform
  unsigned int* address;  // Starting address of the change
  unsigned int* data;     // New data to write
  unsigned short no_words; // Number of words in data array
} diff_op_t;
\end{lstlisting}
This data structure is then used in the Apply phase to apply the changes. The Decode phase is also responsible for verifying the integrity of the patch file, which in this research is of limited functionality, simply verifying that the patch file is in the correct format. To keep the implementation deterministic, memory for the patch file, decoded patch instructions, and data is allocated at compile time in the FRAM.

\subsubsection*{Apply}
The Apply phase is responsible for applying the changes to the binary image. The changes are applied in the order they are read from the patch file, and simply writes the new data to the specified addresses. This introduces the requirement that the patch file is ordered correctly, but this can be verified off the device. 

\begin{lstlisting}[
    caption={The Apply phase of the update procedure.},
    label={lst:apply_phase}
]
void apply(diff_op_t* diff_arr, int diff_size) {
  int i = diff_size - 1;
  for (; i > 0; i--) {
    diff_op_t operation = diff_arr[i];
    memcpy(operation.addr, operation.data, operation.no_words * sizeof(uint));
  }
}
\end{lstlisting}\todo{Shift not implemented yet}

As can be seen in listing \ref{lst:apply_phase}, the Apply phase is a simple loop that iterates over the changes in the patch file and applies them to the binary image. An issue with the implementation is the lack of atomicity in the update procedure. If the update is interrupted, or fails for any reason, the system will be left in an inconsistent state. \todo{Future work}To counteract this, a rollback mechanism could be implemented using the same lambda file, but this was not implemented in this research. 
